[{"title":"代码随想录_day3(链表01)","url":"/2026/01/16/coding_day3/","content":"今天是2026年1月16日，是代码随想录的第三天，主要学习链表的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n203.移除链表元素\n卡哥解析\n\n\n2\n707.设计链表\n卡哥解析\n\n\n3\n206.反转链表\n卡哥解析\n\n\n题目解析203. 移除链表元素\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。\n\n个人解析\n首先是203，移除链表元素\n我们都知道当删除链表某个元素时，其实只需要将该元素的前一个节点的next指针指向该元素的下一个节点即可，因此基于这个思路，我们可以遍历链表，当遇到val时，将前一个节点的next指针指向该元素的下一个节点即可。\n\nclass Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        while (head != NULL &amp;&amp; head-&gt;val == val)        &#123;            ListNode *temp = head;            head = head-&gt;next;            delete temp;        &#125;        ListNode *now = head;        while (now != NULL &amp;&amp; now-&gt;next != NULL)        &#123;            if (now-&gt;next-&gt;val != val)                now = now-&gt;next;            else            &#123;                ListNode *temp = now-&gt;next;                now-&gt;next = now-&gt;next-&gt;next;                delete temp;                temp = nullptr;            &#125;        &#125;        return head;    &#125;&#125;;\n不过这边要注意的是\n\ndelete命令指示释放了tmp指针原本所指的那部分内存，\n被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，\n如果不再加上一句tmp&#x3D;nullptr,tmp会成为乱指的野指针\n如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n\n虽然一开始并没有加delete temp也是AC了，不过后面依旧需要注意这个问题。\n卡哥解析卡哥这边还提出了两种办法，分别是\n\n虚拟头节点\n\n我们可以在头节点之前添加一个虚拟头节点，这样就可以统一处理头节点的情况了。\n\n class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点        dummyHead-&gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作        ListNode* cur = dummyHead;        while (cur-&gt;next != NULL) &#123;            if(cur-&gt;next-&gt;val == val) &#123;                ListNode* tmp = cur-&gt;next;                cur-&gt;next = cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur = cur-&gt;next;            &#125;        &#125;        head = dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;\n\n采用递归的思路\n\n基础情况：对于空链表，不需要移除元素。\n递归情况：首先检查头节点的值是否为 val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为 val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果。\n\n class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        // 基础情况：空链表        if (head == nullptr) &#123;            return nullptr;        &#125;        // 递归处理        if (head-&gt;val == val) &#123;            ListNode* newHead = removeElements(head-&gt;next, val);            delete head;            return newHead;        &#125; else &#123;            head-&gt;next = removeElements(head-&gt;next, val);            return head;        &#125;    &#125;&#125;;\n\n\n707. 设计链表你可以选择使用单链表或者双链表，设计并实现自己的链表。单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n解析\n我觉得这是一道考验链表综合素质的题目，需要考虑到很多边界情况，当然还有index的问题，认真仔细做还是可以摸索下去的，因为本身对链表使用上并没有那么熟悉，因此这边也借鉴了不少卡哥的解析\n\n\n点击展开代码\n\nclass MyLinkedList &#123;public:    struct ListNode &#123;        int val;  // 节点上存储的元素        ListNode *next;  // 指向下一个节点的指针        ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数    &#125;;    MyLinkedList() &#123;        DummyHead = new ListNode(0);        NodeNum = 0;    &#125;        int get(int index) &#123;        if (index &gt; NodeNum - 1 || index &lt; 0)            return -1;        ListNode *RealHead = DummyHead-&gt;next;        while (index--)        &#123;            RealHead = RealHead-&gt;next;        &#125;        return RealHead-&gt;val;    &#125;        void addAtHead(int val) &#123;        ListNode *NewHead = new ListNode(val);        NewHead-&gt;next = DummyHead-&gt;next;        DummyHead-&gt;next = NewHead;        NodeNum++;    &#125;        void addAtTail(int val) &#123;        ListNode *NewTail = new ListNode(val);        ListNode *now = DummyHead;        while (now-&gt;next != nullptr)        &#123;            now = now-&gt;next;        &#125;        now-&gt;next = NewTail;        NodeNum++;    &#125;        void addAtIndex(int index, int val) &#123;        if (index &gt; NodeNum)            return;        index = index &lt;= 0 ? 0 : index;        ListNode *NewNode = new ListNode(val);        ListNode *now = DummyHead;        while (index--)        &#123;            now = now-&gt;next;        &#125;        NewNode-&gt;next = now-&gt;next;        now-&gt;next = NewNode;        NodeNum++;    &#125;        void deleteAtIndex(int index) &#123;        if(index &lt; 0 || index &gt;= NodeNum)            return;        ListNode *now = DummyHead;        while (index--)        &#123;            now = now-&gt;next;        &#125;        ListNode *temp = now-&gt;next;        now-&gt;next = now-&gt;next-&gt;next;        delete temp;        temp = nullptr;        NodeNum--;    &#125;private:    ListNode *DummyHead;    int NodeNum;&#125;;\n\n\n\n当然卡哥这边还写出了双链表的形式，思路和虚拟节点比较类似，创建了一个哨兵系节点，指向头节点和尾节点，这样就可以避免头节点为空的情况，同时也可以避免尾节点为空的情况。\n\n点击展开代码\n\n//采用循环虚拟结点的双链表实现class MyLinkedList &#123;public:    // 定义双向链表节点结构体    struct DList &#123;        int elem; // 节点存储的元素        DList *next; // 指向下一个节点的指针        DList *prev; // 指向上一个节点的指针        // 构造函数，创建一个值为elem的新节点        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) &#123;&#125;;    &#125;;    // 构造函数，初始化链表    MyLinkedList() &#123;        sentinelNode = new DList(0); // 创建哨兵节点，不存储有效数据        sentinelNode-&gt;next = sentinelNode; // 哨兵节点的下一个节点指向自身，形成循环        sentinelNode-&gt;prev = sentinelNode; // 哨兵节点的上一个节点指向自身，形成循环        size = 0; // 初始化链表大小为0    &#125;    // 获取链表中第index个节点的值    int get(int index) &#123;        if (index &gt; (size - 1) || index &lt; 0) &#123; // 检查索引是否超出范围            return -1; // 如果超出范围，返回-1        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index + 1; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标节点            &#125;        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标节点            &#125;        &#125;        num = curNode-&gt;elem; // 获取目标节点的值        return num; // 返回节点的值    &#125;    // 在链表头部添加节点    void addAtHead(int val) &#123;        DList *newNode = new DList(val); // 创建新节点        DList *next = sentinelNode-&gt;next; // 获取当前头节点的下一个节点        newNode-&gt;prev = sentinelNode; // 新节点的上一个节点指向哨兵节点        newNode-&gt;next = next; // 新节点的下一个节点指向原来的头节点        size++; // 链表大小加1        sentinelNode-&gt;next = newNode; // 哨兵节点的下一个节点指向新节点        next-&gt;prev = newNode; // 原来的头节点的上一个节点指向新节点    &#125;    // 在链表尾部添加节点    void addAtTail(int val) &#123;        DList *newNode = new DList(val); // 创建新节点        DList *prev = sentinelNode-&gt;prev; // 获取当前尾节点的上一个节点        newNode-&gt;next = sentinelNode; // 新节点的下一个节点指向哨兵节点        newNode-&gt;prev = prev; // 新节点的上一个节点指向原来的尾节点        size++; // 链表大小加1        sentinelNode-&gt;prev = newNode; // 哨兵节点的上一个节点指向新节点        prev-&gt;next = newNode; // 原来的尾节点的下一个节点指向新节点    &#125;    // 在链表中的第index个节点之前添加值为val的节点    void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123; // 检查索引是否超出范围            return; // 如果超出范围，直接返回        &#125;        if (index &lt;= 0) &#123; // 如果索引为0或负数，在头部添加节点            addAtHead(val);            return;        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标位置的前一个节点            &#125;            DList *temp = curNode-&gt;next; // 获取目标位置的节点            DList *newNode = new DList(val); // 创建新节点            curNode-&gt;next = newNode; // 在目标位置前添加新节点            temp-&gt;prev = newNode; // 目标位置的节点的前一个节点指向新节点            newNode-&gt;next = temp; // 新节点的下一个节点指向目标位置的结点            newNode-&gt;prev = curNode; // 新节点的上一个节点指向当前节点        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标位置的后一个节点            &#125;            DList *temp = curNode-&gt;prev; // 获取目标位置的节点            DList *newNode = new DList(val); // 创建新节点            curNode-&gt;prev = newNode; // 在目标位置后添加新节点            temp-&gt;next = newNode; // 目标位置的节点的下一个节点指向新节点            newNode-&gt;prev = temp; // 新节点的上一个节点指向目标位置的节点            newNode-&gt;next = curNode; // 新节点的下一个节点指向当前节点        &#125;        size++; // 链表大小加1    &#125;    // 删除链表中的第index个节点    void deleteAtIndex(int index) &#123;        if (index &gt; (size - 1) || index &lt; 0) &#123; // 检查索引是否超出范围            return; // 如果超出范围，直接返回        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标位置的前一个节点            &#125;            DList *next = curNode-&gt;next-&gt;next; // 获取目标位置的下一个节点            curNode-&gt;next = next; // 删除目标位置的节点            next-&gt;prev = curNode; // 目标位置的下一个节点的前一个节点指向当前节点        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index - 1; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标位置的后一个节点            &#125;            DList *prev = curNode-&gt;prev-&gt;prev; // 获取目标位置的下一个节点            curNode-&gt;prev = prev; // 删除目标位置的节点            prev-&gt;next = curNode; // 目标位置的下一个节点的下一个节点指向当前节点        &#125;        size--; // 链表大小减1    &#125;private:    int size; // 链表的大小    DList *sentinelNode; // 哨兵节点的指针&#125;;\n\n\n\n206.反转链表\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n个人解析\n这边想的其实比较简单，采用双指针的方法，一个指针指向当前节点，一个指针指向当前节点的前一个节点，每次遍历到当前节点时，将当前节点的下一个节点指向前一个节点，然后将前一个节点指向当前节点，当前节点指向当前节点的下一个节点。即完成反转。\n\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *now = head;        ListNode *pre = NULL;        while (now)        &#123;            ListNode *temp = now-&gt;next;            now-&gt;next = pre;            pre = now;            now = temp;        &#125;        return pre;    &#125;&#125;;\n卡哥解析当然卡哥这边还提出了两种办法\n\n递归法\n因为本身是重复性的操作，所以可以采用递归的方法。\n\n class Solution &#123;public:    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;        if(cur == NULL) return pre;        ListNode* temp = cur-&gt;next;        cur-&gt;next = pre;        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步        // pre = cur;        // cur = temp;        return reverse(cur,temp);    &#125;    ListNode* reverseList(ListNode* head) &#123;        // 和双指针法初始化是一样的逻辑        // ListNode* cur = head;        // ListNode* pre = NULL;        return reverse(NULL, head);    &#125;&#125;;\n从后向前翻转\n也是采用了递归的方法，不过顺序有所不同\n\n class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        // 边缘条件判断        if(head == NULL) return NULL;        if (head-&gt;next == NULL) return head;                // 递归调用，翻转第二个节点开始往后的链表        ListNode *last = reverseList(head-&gt;next);        // 翻转头节点与第二个节点的指向        head-&gt;next-&gt;next = head;        // 此时的 head 节点为尾节点，next 需要指向 NULL        head-&gt;next = NULL;        return last;    &#125;&#125;; \n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day1(数组01)","url":"/2026/01/14/coding_day1/","content":"   今天是2026年1月14日，是代码随想录的第一天，主要学习数组的相关知识。\n力扣题目及卡哥解析\n704. 二分查找\n卡哥解析：704. 二分查找\n\n\n27. 移除元素\n卡哥解析：27. 移除元素\n\n\n977.有序数组的平方\n卡哥解析：977.有序数组的平方\n\n\n\n题目解析704. 二分查找\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。\n你必须编写一个具有 O(log n) 时间复杂度的算法。\n\n个人解析   首先是704二分查找，题目要求在有序数组中查找目标值的索引，时间复杂度是O(log n)，空间复杂度是O(1)，刚刚好符合题目要求。   二分查找的思路是，每次取数组的中间元素，与目标值比较，如果相等则返回索引，如果中间元素大于目标值，则在左半部分继续查找，否则在右半部分继续查找。   乍一看这题目还以为回到了高中 (T.T)   因此直接贴出我的代码\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid +1            else:                right = mid -1        return -1\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0;        int right = nums.size() - 1;                while (left &lt;= right)        &#123;            int mid = (left + right) / 2;            if(nums[mid] == target)                return mid;            else if(nums[mid] &lt; target)                left = mid + 1;            else                right = mid - 1;        &#125;        return -1;    &#125;&#125;;\n\n卡哥解析\n我与卡哥这一道题的思路基本一致，原理就不展开了。\n不过，二分法的实现需重点关注边界条件，即搜索区间的取值范围及开闭区间的定义形式，具体可分为两种情况：\n若采用闭区间 [left, right] 的搜索形式，left 与 right 的初始值应分别设为 0 和 n-1。在每次迭代更新区间时，需 left &#x3D; mid + 1、right &#x3D; mid - 1，以此规避因区间无法收敛而导致的死循环问题。\n若采用开区间 [left, right) 的搜索形式，left 与 right 的初始值应分别设为 0 和 n。由于开区间的右边界 right 本身不包含在搜索范围内，因此迭代时只需 left &#x3D; mid + 1、right &#x3D; mid，无需额外对边界值进行加 1 或减 1 操作。\n\n\n\n\n27. 移除元素\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n个人解析\n拿到题目第一想法就是拿到两个指针，一个指向数组头部，一个指向数组尾部，然后分别向中间移动，当头部指针指向的值等于目标值时，就用尾部指针指向的值覆盖头部指针指向的值，然后尾部指针向中间移动，直到两个指针相遇。后来看解析才知道这是双指针方法\n最后返回新的数组长度，即头部指针的索引加一。这边当时没看仔细题目，一直想着要返回数组，测试一直不通过，迷迷糊糊折腾了好久才发现只需要返回新长度k值，而数组已经是修改过了的\n然后贴出我的代码\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int head = 0;        int tail = nums.size() - 1;        while (head &lt;= tail)         &#123;            if (nums[head] == val)             &#123;                nums[head] = nums[tail];                tail--;            &#125;             else                head++;        &#125;        return head;    &#125;&#125;;\n\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt; right:            if nums[left] == val:                nums[left] = nums[right]                right -= 1            else:                left += 1        return left\n\n卡哥解析\n卡哥给出了两种办法，分别是\n双指针法\n双指针法和我这个类似，就不过多解释\n\n\n快慢指针法\n快慢指针法的思路是，快指针用来遍历数组，慢指针用来指向新数组的最后一个元素。当快指针指向的值不等于目标值时，就用快指针指向的值覆盖慢指针指向的值，然后慢指针向中间移动。最后返回慢指针的索引加一。  具体代码为\n\n  class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n\n\n\n977. 有序数组的平方\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n个人解析\n看到题目想的也是双指针法，和卡哥类似，都是分别从头和尾部查看数组，比较其绝对值大小，再放入到新数组当中\n\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = nums.size() - 1;        int k = tail;        vector&lt;int&gt; res(nums.size());        while (head &lt;= tail) &#123;            if(abs(nums[head]) &gt; abs(nums[tail])) &#123;                res[k--] = nums[head] * nums[head];                head++;            &#125; else &#123;                res[k--] = nums[tail] * nums[tail];                tail--;            &#125;        &#125;        return res;    &#125;&#125;;\n\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        head = 0        tail = len(nums) - 1        k = tail        res = [0] * len(nums)        while head &lt;= tail:            if abs(nums[head]) &gt; abs(nums[tail]):                res[k] = nums[head] ** 2                head += 1            else:                res[k] = nums[tail] ** 2                tail -= 1            k -= 1        return res\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day2(数组02)","url":"/2026/01/15/coding-day2/","content":"今天是2026年1月15日，是代码随想录的第二天，主要学习数组的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n209.长度最小的子数组\n卡哥解析\n\n\n2\n59.螺旋矩阵II\n卡哥解析\n\n\n3\n卡哥58.区间和\n卡哥解析\n\n\n4\n卡哥44.开发商购买土地\n卡哥解析\n\n\n题目解析209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n个人解析\n首先是209，长度最小的子数组\n卡哥题目那边提了一嘴是滑动窗口，想了一下应该是应该和快慢指针类似，只不过这里是用一个指针指向窗口的头部，一个指针指向窗口的尾部，然后根据窗口内的元素和与目标值的比较，来移动指针，以此来逐渐寻找最小窗口，有了这样的思路那么代码就比较好写了。\n\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = 0;        int sum = 0;        int MiniLen = nums.size() + 1;        for (tail = 0; tail &lt; nums.size(); tail++) &#123;            sum += nums[tail];            while (sum &gt;= target)&#123;                if (MiniLen &gt; tail - head + 1)&#123;                    MiniLen = tail - head + 1;                &#125;                sum -= nums[head++];            &#125;        &#125;        return (MiniLen == (nums.size() + 1)) ? 0 : MiniLen;    &#125;&#125;;\n\n\n59. 螺旋矩阵 II\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵。\n\n个人解析\n拿到题目说实话并没有很好的思路，于是尝试暴力求解，根据矩阵的四个方向，分别填充数字，填充完成后，返回矩阵。\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        int up = 0;        int left = 0;        int down = n - 1;        int right = n - 1;        int count = 1;        vector&lt;vector&lt;int&gt;&gt;res(n, vector&lt;int&gt;(n,0));        while (left &lt;= right and up &lt;= down)&#123;            for (int i = left; i &lt; right + 1; i++)                res[up][i] = count++;            up++;            for (int i = up; i &lt; down + 1; i++)                res[i][right] = count++;            right--;            for (int i = right; i &gt; left - 1; i--)                res[down][i] = count++;            down--;            for (int i = down; i &gt;  up - 1; i--)                res[i][left] = count++;            left++;        &#125;        return res;    &#125;&#125;;\n\n卡哥解析\n卡哥的解法也是类似，只不过他首先判断的是总轮数，而我是判断的是当前数据是否满足条件。\n\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count = 1; // 用来给矩阵中每一个空格赋值        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i = startx;            j = starty;            // 下面开始的四个for就是模拟转了一圈            // 模拟填充上行从左到右(左闭右开)            for (j; j &lt; n - offset; j++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充右列从上到下(左闭右开)            for (i; i &lt; n - offset; i++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] = count++;            &#125;            // 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] = count++;            &#125;            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            // offset 控制每一圈里每一条边遍历的长度            offset += 1;        &#125;        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] = count;        &#125;        return res;    &#125;&#125;;\n\n\n\n58. 区间和\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n\n解析\n暴力求解就不提了，这里主要介绍一下前缀和的方法。\n前缀和是指一个数组的某下标之前的所有数组元素的和（包含其自身）。我们可以用一个数组 P 来表示原数组 A 的前缀和，即 P[i] &#x3D; A[0] + A[1] + … + A[i]。那么区间 [i, j] 的和就可以表示为 P[j] - P[i - 1]。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int n;    int head, tail;    int sum = 0;    cin &gt;&gt; n;    vector&lt;int&gt; nums(n);    vector&lt;int&gt; SumNums(n);    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        sum += nums[i];        SumNums[i] = sum;    &#125;    while (scanf(&quot;%d%d&quot;, &amp;head, &amp;tail) != EOF)    &#123;        if(head)            printf(&quot;%d\\n&quot;, SumNums[tail] - SumNums[head - 1]);        else            printf(&quot;%d\\n&quot;, SumNums[tail]);    &#125;    return 0;&#125;\n  由于对vector并不是很熟悉，在一开始初始化数组时一不小心将  vector&lt;int&gt; SumNums(n);  写成了  vector&lt;int&gt; SumNums[n];  而这种初始化方式是错误的，因为试图定义 vector 类型的数组，虽然合法但是这种并不适用在本题中。\n\n44. 开发商购买土地  在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。\n解析\n有了前缀和的铺垫，这一道题就很好理解了，本质是建立一个二维前缀和数组，用于快速计算任意子区域的土地总价值。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    int n, m, sum = 0, num;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;int&gt; rowSum(n, 0);    vector&lt;int&gt; colSum(m, 0);    int minDiff = INT_MAX;    int temp = 0;    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; m; j++)        &#123;            cin &gt;&gt; num;            sum += num;            rowSum[i] += num;            colSum[j] += num;        &#125;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        temp += rowSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    temp = 0;    for (int i = 0; i &lt; m; i++)    &#123;        temp += colSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    cout &lt;&lt; minDiff &lt;&lt; endl;    return 0;&#125;\n总结  这两天的题目主要是复习了数组的相关知识，包括二分法，双指针法，前缀和等。\n\n二分法：主要是要注意边界条件的处理，以及循环不变量的维护。\n双指针法：主要是要注意指针的移动条件，以及指针的边界处理。\n前缀和：其思想是将一个数组的前缀和存储在另一个数组中，通过前缀和数组可以快速计算任意子数组的和。\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"Hello World","url":"/2026/01/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["学习笔记"],"tags":["hexo"]},{"title":"my blog test","url":"/2026/01/12/my-blog-test/","content":"1.1 标题测试一级标题二级标题三级标题四级标题五级标题六级标题1.2 文本样式测试粗体文本斜体文本粗斜体文本删除线文本下划线文本高亮文本小号文本大号文本\n1.3 列表测试无序列表\n项目1\n项目2\n子项目2.1\n子项目2.2\n子子项目2.2.1\n\n\n\n\n\n有序列表\n第一个项目\n第二个项目\n子项目2.1\n子项目2.2\n\n\n第三个项目\n\n任务列表\n 完成的任务\n 未完成的任务\n 已完成的任务2\n\n2. 代码测试2.1 行内代码这里是行内代码 console.log(&#39;Hello World&#39;) 的测试。\n2.2 代码块测试JavaScript代码function hello() &#123;  console.log(&#x27;Hello, Hexo!&#x27;);&#125;hello();\n\nPython代码def hello():    print(&quot;Hello, Hexo!&quot;)hello()\n\nHTML代码&lt;div class=&quot;test&quot;&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  &lt;p&gt;This is a test&lt;/p&gt;&lt;/div&gt;\n\nCSS代码.test &#123;  color: red;  font-size: 16px;&#125;\n\n3. 链接和图片测试3.1 普通链接Hexo官方网站\n3.2 带标题的链接Hexo官方网站\n3.3 图片测试\n3.4 带链接的图片\n4. 引用测试4.1 基本引用\n这是一段引用文本。引用可以跨越多行。\n\n4.2 嵌套引用\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n4.3 引用中包含其他元素\n引用中的标题\n引用中的列表项1\n引用中的列表项2\n\n引用中的普通文本。\n\n5. 表格测试5.1 基本表格\n\n\n姓名\n年龄\n职业\n\n\n\n张三\n25\n工程师\n\n\n李四\n30\n设计师\n\n\n王五\n35\n产品经理\n\n\n5.2 对齐方式测试\n\n\n左对齐\n居中对齐\n右对齐\n\n\n\n内容1\n内容2\n内容3\n\n\n长内容1\n长内容2\n长内容3\n\n\n6. 分隔线测试这是上面的内容。\n\n这是中间的内容。\n\n这是下面的内容。\n7. 脚注测试这是一段带有脚注的文本^1。这是另一段带有脚注的文本^2。\n这是脚注的第二行。\n\n8. 数学公式测试8.1 行内公式E &#x3D; mc²\n8.2 块级公式$$\\int_{a}^{b} f(x) dx &#x3D; F(b) - F(a)$$\n9. 特殊语法测试9.1 自动链接https://hexo.iotest@example.com\n9.2 反斜杠转义*这不是斜体*_这不是下划线_#这不是标题#\n9.3 表情符号测试:smile: :laughing: :blush: :smiley: :relaxed:\n10. Hexo特定功能测试10.1 前置声明测试本文档使用了以下前置声明：\n\ntitle: 博客书写功能测试\ndate: 2026-01-12 12:00:00\ntags: 测试, 功能\ncategories: 技术\n\n10.2 标签和分类测试标签：测试、功能分类：技术\n10.3 代码高亮测试// 这是一段JavaScript代码const hexo = &#x27;Hexo&#x27;;console.log(`Welcome to $&#123;hexo&#125;!`);","categories":["学习笔记"],"tags":["test"]}]