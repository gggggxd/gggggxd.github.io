[{"title":"代码随想录_day1(数组01)","url":"/2026/01/14/coding_day1/","content":"   今天是2026年1月14日，是代码随想录的第一天，主要学习数组的相关知识。\n力扣题目及卡哥解析\n704. 二分查找\n卡哥解析：704. 二分查找\n\n\n27. 移除元素\n卡哥解析：27. 移除元素\n\n\n977.有序数组的平方\n卡哥解析：977.有序数组的平方\n\n\n\n题目解析704. 二分查找\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。\n你必须编写一个具有 O(log n) 时间复杂度的算法。\n\n个人解析   首先是704二分查找，题目要求在有序数组中查找目标值的索引，时间复杂度是O(log n)，空间复杂度是O(1)，刚刚好符合题目要求。   二分查找的思路是，每次取数组的中间元素，与目标值比较，如果相等则返回索引，如果中间元素大于目标值，则在左半部分继续查找，否则在右半部分继续查找。   乍一看这题目还以为回到了高中 (T.T)   因此直接贴出我的代码\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid +1            else:                right = mid -1        return -1\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0;        int right = nums.size() - 1;                while (left &lt;= right)        &#123;            int mid = (left + right) / 2;            if(nums[mid] == target)                return mid;            else if(nums[mid] &lt; target)                left = mid + 1;            else                right = mid - 1;        &#125;        return -1;    &#125;&#125;;\n\n卡哥解析\n我与卡哥这一道题的思路基本一致，原理就不展开了。\n不过，二分法的实现需重点关注边界条件，即搜索区间的取值范围及开闭区间的定义形式，具体可分为两种情况：\n若采用闭区间 [left, right] 的搜索形式，left 与 right 的初始值应分别设为 0 和 n-1。在每次迭代更新区间时，需 left &#x3D; mid + 1、right &#x3D; mid - 1，以此规避因区间无法收敛而导致的死循环问题。\n若采用开区间 [left, right) 的搜索形式，left 与 right 的初始值应分别设为 0 和 n。由于开区间的右边界 right 本身不包含在搜索范围内，因此迭代时只需 left &#x3D; mid + 1、right &#x3D; mid，无需额外对边界值进行加 1 或减 1 操作。\n\n\n\n\n27. 移除元素\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n个人解析\n拿到题目第一想法就是拿到两个指针，一个指向数组头部，一个指向数组尾部，然后分别向中间移动，当头部指针指向的值等于目标值时，就用尾部指针指向的值覆盖头部指针指向的值，然后尾部指针向中间移动，直到两个指针相遇。后来看解析才知道这是双指针方法\n最后返回新的数组长度，即头部指针的索引加一。这边当时没看仔细题目，一直想着要返回数组，测试一直不通过，迷迷糊糊折腾了好久才发现只需要返回新长度k值，而数组已经是修改过了的\n然后贴出我的代码\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int head = 0;        int tail = nums.size() - 1;        while (head &lt;= tail)         &#123;            if (nums[head] == val)             &#123;                nums[head] = nums[tail];                tail--;            &#125;             else                head++;        &#125;        return head;    &#125;&#125;;\n\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt; right:            if nums[left] == val:                nums[left] = nums[right]                right -= 1            else:                left += 1        return left\n\n卡哥解析\n卡哥给出了两种办法，分别是\n双指针法\n双指针法和我这个类似，就不过多解释\n\n\n快慢指针法\n快慢指针法的思路是，快指针用来遍历数组，慢指针用来指向新数组的最后一个元素。当快指针指向的值不等于目标值时，就用快指针指向的值覆盖慢指针指向的值，然后慢指针向中间移动。最后返回慢指针的索引加一。  具体代码为\n\n  class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n\n\n\n977. 有序数组的平方\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n个人解析\n看到题目想的也是双指针法，和卡哥类似，都是分别从头和尾部查看数组，比较其绝对值大小，再放入到新数组当中\n\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = nums.size() - 1;        int k = tail;        vector&lt;int&gt; res(nums.size());        while (head &lt;= tail) &#123;            if(abs(nums[head]) &gt; abs(nums[tail])) &#123;                res[k--] = nums[head] * nums[head];                head++;            &#125; else &#123;                res[k--] = nums[tail] * nums[tail];                tail--;            &#125;        &#125;        return res;    &#125;&#125;;\n\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        head = 0        tail = len(nums) - 1        k = tail        res = [0] * len(nums)        while head &lt;= tail:            if abs(nums[head]) &gt; abs(nums[tail]):                res[k] = nums[head] ** 2                head += 1            else:                res[k] = nums[tail] ** 2                tail -= 1            k -= 1        return res\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"Hello World","url":"/2026/01/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["学习笔记"],"tags":["hexo"]},{"title":"my blog test","url":"/2026/01/12/my-blog-test/","content":"1.1 标题测试一级标题二级标题三级标题四级标题五级标题六级标题1.2 文本样式测试粗体文本斜体文本粗斜体文本删除线文本下划线文本高亮文本小号文本大号文本\n1.3 列表测试无序列表\n项目1\n项目2\n子项目2.1\n子项目2.2\n子子项目2.2.1\n\n\n\n\n\n有序列表\n第一个项目\n第二个项目\n子项目2.1\n子项目2.2\n\n\n第三个项目\n\n任务列表\n 完成的任务\n 未完成的任务\n 已完成的任务2\n\n2. 代码测试2.1 行内代码这里是行内代码 console.log(&#39;Hello World&#39;) 的测试。\n2.2 代码块测试JavaScript代码function hello() &#123;  console.log(&#x27;Hello, Hexo!&#x27;);&#125;hello();\n\nPython代码def hello():    print(&quot;Hello, Hexo!&quot;)hello()\n\nHTML代码&lt;div class=&quot;test&quot;&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  &lt;p&gt;This is a test&lt;/p&gt;&lt;/div&gt;\n\nCSS代码.test &#123;  color: red;  font-size: 16px;&#125;\n\n3. 链接和图片测试3.1 普通链接Hexo官方网站\n3.2 带标题的链接Hexo官方网站\n3.3 图片测试\n3.4 带链接的图片\n4. 引用测试4.1 基本引用\n这是一段引用文本。引用可以跨越多行。\n\n4.2 嵌套引用\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n4.3 引用中包含其他元素\n引用中的标题\n引用中的列表项1\n引用中的列表项2\n\n引用中的普通文本。\n\n5. 表格测试5.1 基本表格\n\n\n姓名\n年龄\n职业\n\n\n\n张三\n25\n工程师\n\n\n李四\n30\n设计师\n\n\n王五\n35\n产品经理\n\n\n5.2 对齐方式测试\n\n\n左对齐\n居中对齐\n右对齐\n\n\n\n内容1\n内容2\n内容3\n\n\n长内容1\n长内容2\n长内容3\n\n\n6. 分隔线测试这是上面的内容。\n\n这是中间的内容。\n\n这是下面的内容。\n7. 脚注测试这是一段带有脚注的文本^1。这是另一段带有脚注的文本^2。\n这是脚注的第二行。\n\n8. 数学公式测试8.1 行内公式E &#x3D; mc²\n8.2 块级公式$$\\int_{a}^{b} f(x) dx &#x3D; F(b) - F(a)$$\n9. 特殊语法测试9.1 自动链接https://hexo.iotest@example.com\n9.2 反斜杠转义*这不是斜体*_这不是下划线_#这不是标题#\n9.3 表情符号测试:smile: :laughing: :blush: :smiley: :relaxed:\n10. Hexo特定功能测试10.1 前置声明测试本文档使用了以下前置声明：\n\ntitle: 博客书写功能测试\ndate: 2026-01-12 12:00:00\ntags: 测试, 功能\ncategories: 技术\n\n10.2 标签和分类测试标签：测试、功能分类：技术\n10.3 代码高亮测试// 这是一段JavaScript代码const hexo = &#x27;Hexo&#x27;;console.log(`Welcome to $&#123;hexo&#125;!`);","categories":["学习笔记"],"tags":["test"]}]