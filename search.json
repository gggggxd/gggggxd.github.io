[{"title":"代码随想录_day1(数组01)","url":"/2026/01/14/coding_day1/","content":"   今天是2026年1月14日，是代码随想录的第一天，主要学习数组的相关知识。\n力扣题目及卡哥解析\n704. 二分查找\n卡哥解析：704. 二分查找\n\n\n27. 移除元素\n卡哥解析：27. 移除元素\n\n\n977.有序数组的平方\n卡哥解析：977.有序数组的平方\n\n\n\n题目解析704. 二分查找\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。\n你必须编写一个具有 O(log n) 时间复杂度的算法。\n\n个人解析   首先是704二分查找，题目要求在有序数组中查找目标值的索引，时间复杂度是O(log n)，空间复杂度是O(1)，刚刚好符合题目要求。   二分查找的思路是，每次取数组的中间元素，与目标值比较，如果相等则返回索引，如果中间元素大于目标值，则在左半部分继续查找，否则在右半部分继续查找。   乍一看这题目还以为回到了高中 (T.T)   因此直接贴出我的代码\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid +1            else:                right = mid -1        return -1\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0;        int right = nums.size() - 1;                while (left &lt;= right)        &#123;            int mid = (left + right) / 2;            if(nums[mid] == target)                return mid;            else if(nums[mid] &lt; target)                left = mid + 1;            else                right = mid - 1;        &#125;        return -1;    &#125;&#125;;\n\n卡哥解析\n我与卡哥这一道题的思路基本一致，原理就不展开了。\n不过，二分法的实现需重点关注边界条件，即搜索区间的取值范围及开闭区间的定义形式，具体可分为两种情况：\n若采用闭区间 [left, right] 的搜索形式，left 与 right 的初始值应分别设为 0 和 n-1。在每次迭代更新区间时，需 left &#x3D; mid + 1、right &#x3D; mid - 1，以此规避因区间无法收敛而导致的死循环问题。\n若采用开区间 [left, right) 的搜索形式，left 与 right 的初始值应分别设为 0 和 n。由于开区间的右边界 right 本身不包含在搜索范围内，因此迭代时只需 left &#x3D; mid + 1、right &#x3D; mid，无需额外对边界值进行加 1 或减 1 操作。\n\n\n\n\n27. 移除元素\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n个人解析\n拿到题目第一想法就是拿到两个指针，一个指向数组头部，一个指向数组尾部，然后分别向中间移动，当头部指针指向的值等于目标值时，就用尾部指针指向的值覆盖头部指针指向的值，然后尾部指针向中间移动，直到两个指针相遇。后来看解析才知道这是双指针方法\n最后返回新的数组长度，即头部指针的索引加一。这边当时没看仔细题目，一直想着要返回数组，测试一直不通过，迷迷糊糊折腾了好久才发现只需要返回新长度k值，而数组已经是修改过了的\n然后贴出我的代码\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int head = 0;        int tail = nums.size() - 1;        while (head &lt;= tail)         &#123;            if (nums[head] == val)             &#123;                nums[head] = nums[tail];                tail--;            &#125;             else                head++;        &#125;        return head;    &#125;&#125;;\n\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt; right:            if nums[left] == val:                nums[left] = nums[right]                right -= 1            else:                left += 1        return left\n\n卡哥解析\n卡哥给出了两种办法，分别是\n双指针法\n双指针法和我这个类似，就不过多解释\n\n\n快慢指针法\n快慢指针法的思路是，快指针用来遍历数组，慢指针用来指向新数组的最后一个元素。当快指针指向的值不等于目标值时，就用快指针指向的值覆盖慢指针指向的值，然后慢指针向中间移动。最后返回慢指针的索引加一。  具体代码为\n\n  class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n\n\n\n977. 有序数组的平方\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n个人解析\n看到题目想的也是双指针法，和卡哥类似，都是分别从头和尾部查看数组，比较其绝对值大小，再放入到新数组当中\n\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = nums.size() - 1;        int k = tail;        vector&lt;int&gt; res(nums.size());        while (head &lt;= tail) &#123;            if(abs(nums[head]) &gt; abs(nums[tail])) &#123;                res[k--] = nums[head] * nums[head];                head++;            &#125; else &#123;                res[k--] = nums[tail] * nums[tail];                tail--;            &#125;        &#125;        return res;    &#125;&#125;;\n\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        head = 0        tail = len(nums) - 1        k = tail        res = [0] * len(nums)        while head &lt;= tail:            if abs(nums[head]) &gt; abs(nums[tail]):                res[k] = nums[head] ** 2                head += 1            else:                res[k] = nums[tail] ** 2                tail -= 1            k -= 1        return res\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"Hello World","url":"/2026/01/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["学习笔记"],"tags":["hexo"]},{"title":"my blog test","url":"/2026/01/12/my-blog-test/","content":"1.1 标题测试一级标题二级标题三级标题四级标题五级标题六级标题1.2 文本样式测试粗体文本斜体文本粗斜体文本删除线文本下划线文本高亮文本小号文本大号文本\n1.3 列表测试无序列表\n项目1\n项目2\n子项目2.1\n子项目2.2\n子子项目2.2.1\n\n\n\n\n\n有序列表\n第一个项目\n第二个项目\n子项目2.1\n子项目2.2\n\n\n第三个项目\n\n任务列表\n 完成的任务\n 未完成的任务\n 已完成的任务2\n\n2. 代码测试2.1 行内代码这里是行内代码 console.log(&#39;Hello World&#39;) 的测试。\n2.2 代码块测试JavaScript代码function hello() &#123;  console.log(&#x27;Hello, Hexo!&#x27;);&#125;hello();\n\nPython代码def hello():    print(&quot;Hello, Hexo!&quot;)hello()\n\nHTML代码&lt;div class=&quot;test&quot;&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  &lt;p&gt;This is a test&lt;/p&gt;&lt;/div&gt;\n\nCSS代码.test &#123;  color: red;  font-size: 16px;&#125;\n\n3. 链接和图片测试3.1 普通链接Hexo官方网站\n3.2 带标题的链接Hexo官方网站\n3.3 图片测试\n3.4 带链接的图片\n4. 引用测试4.1 基本引用\n这是一段引用文本。引用可以跨越多行。\n\n4.2 嵌套引用\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n4.3 引用中包含其他元素\n引用中的标题\n引用中的列表项1\n引用中的列表项2\n\n引用中的普通文本。\n\n5. 表格测试5.1 基本表格\n\n\n姓名\n年龄\n职业\n\n\n\n张三\n25\n工程师\n\n\n李四\n30\n设计师\n\n\n王五\n35\n产品经理\n\n\n5.2 对齐方式测试\n\n\n左对齐\n居中对齐\n右对齐\n\n\n\n内容1\n内容2\n内容3\n\n\n长内容1\n长内容2\n长内容3\n\n\n6. 分隔线测试这是上面的内容。\n\n这是中间的内容。\n\n这是下面的内容。\n7. 脚注测试这是一段带有脚注的文本^1。这是另一段带有脚注的文本^2。\n这是脚注的第二行。\n\n8. 数学公式测试8.1 行内公式E &#x3D; mc²\n8.2 块级公式$$\\int_{a}^{b} f(x) dx &#x3D; F(b) - F(a)$$\n9. 特殊语法测试9.1 自动链接https://hexo.iotest@example.com\n9.2 反斜杠转义*这不是斜体*_这不是下划线_#这不是标题#\n9.3 表情符号测试:smile: :laughing: :blush: :smiley: :relaxed:\n10. Hexo特定功能测试10.1 前置声明测试本文档使用了以下前置声明：\n\ntitle: 博客书写功能测试\ndate: 2026-01-12 12:00:00\ntags: 测试, 功能\ncategories: 技术\n\n10.2 标签和分类测试标签：测试、功能分类：技术\n10.3 代码高亮测试// 这是一段JavaScript代码const hexo = &#x27;Hexo&#x27;;console.log(`Welcome to $&#123;hexo&#125;!`);","categories":["学习笔记"],"tags":["test"]},{"title":"代码随想录_day2(数组02)","url":"/2026/01/15/coding-day2/","content":"今天是2026年1月15日，是代码随想录的第二天，主要学习数组的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n209.长度最小的子数组\n卡哥解析\n\n\n2\n59.螺旋矩阵II\n卡哥解析\n\n\n3\n卡哥58.区间和\n卡哥解析\n\n\n4\n卡哥44.开发商购买土地\n卡哥解析\n\n\n题目解析209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n个人解析\n首先是209，长度最小的子数组\n卡哥题目那边提了一嘴是滑动窗口，想了一下应该是应该和快慢指针类似，只不过这里是用一个指针指向窗口的头部，一个指针指向窗口的尾部，然后根据窗口内的元素和与目标值的比较，来移动指针，以此来逐渐寻找最小窗口，有了这样的思路那么代码就比较好写了。\n\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = 0;        int sum = 0;        int MiniLen = nums.size() + 1;        for (tail = 0; tail &lt; nums.size(); tail++) &#123;            sum += nums[tail];            while (sum &gt;= target)&#123;                if (MiniLen &gt; tail - head + 1)&#123;                    MiniLen = tail - head + 1;                &#125;                sum -= nums[head++];            &#125;        &#125;        return (MiniLen == (nums.size() + 1)) ? 0 : MiniLen;    &#125;&#125;;\n\n\n59. 螺旋矩阵 II\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵。\n\n个人解析\n拿到题目说实话并没有很好的思路，于是尝试暴力求解，根据矩阵的四个方向，分别填充数字，填充完成后，返回矩阵。\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        int up = 0;        int left = 0;        int down = n - 1;        int right = n - 1;        int count = 1;        vector&lt;vector&lt;int&gt;&gt;res(n, vector&lt;int&gt;(n,0));        while (left &lt;= right and up &lt;= down)&#123;            for (int i = left; i &lt; right + 1; i++)                res[up][i] = count++;            up++;            for (int i = up; i &lt; down + 1; i++)                res[i][right] = count++;            right--;            for (int i = right; i &gt; left - 1; i--)                res[down][i] = count++;            down--;            for (int i = down; i &gt;  up - 1; i--)                res[i][left] = count++;            left++;        &#125;        return res;    &#125;&#125;;\n\n卡哥解析\n卡哥的解法也是类似，只不过他首先判断的是总轮数，而我是判断的是当前数据是否满足条件。\n\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count = 1; // 用来给矩阵中每一个空格赋值        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i = startx;            j = starty;            // 下面开始的四个for就是模拟转了一圈            // 模拟填充上行从左到右(左闭右开)            for (j; j &lt; n - offset; j++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充右列从上到下(左闭右开)            for (i; i &lt; n - offset; i++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] = count++;            &#125;            // 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] = count++;            &#125;            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            // offset 控制每一圈里每一条边遍历的长度            offset += 1;        &#125;        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] = count;        &#125;        return res;    &#125;&#125;;\n\n\n\n58. 区间和\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n\n解析\n暴力求解就不提了，这里主要介绍一下前缀和的方法。\n前缀和是指一个数组的某下标之前的所有数组元素的和（包含其自身）。我们可以用一个数组 P 来表示原数组 A 的前缀和，即 P[i] &#x3D; A[0] + A[1] + … + A[i]。那么区间 [i, j] 的和就可以表示为 P[j] - P[i - 1]。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int n;    int head, tail;    int sum = 0;    cin &gt;&gt; n;    vector&lt;int&gt; nums(n);    vector&lt;int&gt; SumNums(n);    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        sum += nums[i];        SumNums[i] = sum;    &#125;    while (scanf(&quot;%d%d&quot;, &amp;head, &amp;tail) != EOF)    &#123;        if(head)            printf(&quot;%d\\n&quot;, SumNums[tail] - SumNums[head - 1]);        else            printf(&quot;%d\\n&quot;, SumNums[tail]);    &#125;    return 0;&#125;\n  由于对vector并不是很熟悉，在一开始初始化数组时一不小心将  vector&lt;int&gt; SumNums(n);  写成了  vector&lt;int&gt; SumNums[n];  而这种初始化方式是错误的，因为试图定义 vector 类型的数组，虽然合法但是这种并不适用在本题中。\n\n44. 开发商购买土地  在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。\n解析\n有了前缀和的铺垫，这一道题就很好理解了，本质是建立一个二维前缀和数组，用于快速计算任意子区域的土地总价值。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    int n, m, sum = 0, num;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;int&gt; rowSum(n, 0);    vector&lt;int&gt; colSum(m, 0);    int minDiff = INT_MAX;    int temp = 0;    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; m; j++)        &#123;            cin &gt;&gt; num;            sum += num;            rowSum[i] += num;            colSum[j] += num;        &#125;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        temp += rowSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    temp = 0;    for (int i = 0; i &lt; m; i++)    &#123;        temp += colSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    cout &lt;&lt; minDiff &lt;&lt; endl;    return 0;&#125;\n总结  这两天的题目主要是复习了数组的相关知识，包括二分法，双指针法，前缀和等。\n\n二分法：主要是要注意边界条件的处理，以及循环不变量的维护。\n双指针法：主要是要注意指针的移动条件，以及指针的边界处理。\n前缀和：其思想是将一个数组的前缀和存储在另一个数组中，通过前缀和数组可以快速计算任意子数组的和。\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]}]