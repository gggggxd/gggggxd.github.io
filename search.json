[{"title":"代码随想录_day3(链表01)","url":"/2026/01/16/coding_day3/","content":"今天是2026年1月16日，是代码随想录的第三天，主要学习链表的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n203.移除链表元素\n卡哥解析\n\n\n2\n707.设计链表\n卡哥解析\n\n\n3\n206.反转链表\n卡哥解析\n\n\n题目解析203. 移除链表元素\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。\n\n个人解析\n首先是203，移除链表元素\n我们都知道当删除链表某个元素时，其实只需要将该元素的前一个节点的next指针指向该元素的下一个节点即可，因此基于这个思路，我们可以遍历链表，当遇到val时，将前一个节点的next指针指向该元素的下一个节点即可。\n\nclass Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        while (head != NULL &amp;&amp; head-&gt;val == val)        &#123;            ListNode *temp = head;            head = head-&gt;next;            delete temp;        &#125;        ListNode *now = head;        while (now != NULL &amp;&amp; now-&gt;next != NULL)        &#123;            if (now-&gt;next-&gt;val != val)                now = now-&gt;next;            else            &#123;                ListNode *temp = now-&gt;next;                now-&gt;next = now-&gt;next-&gt;next;                delete temp;                temp = nullptr;            &#125;        &#125;        return head;    &#125;&#125;;\n不过这边要注意的是\n\ndelete命令指示释放了tmp指针原本所指的那部分内存，\n被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，\n如果不再加上一句tmp&#x3D;nullptr,tmp会成为乱指的野指针\n如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n\n虽然一开始并没有加delete temp也是AC了，不过后面依旧需要注意这个问题。\n卡哥解析卡哥这边还提出了两种办法，分别是\n\n虚拟头节点\n\n我们可以在头节点之前添加一个虚拟头节点，这样就可以统一处理头节点的情况了。\n\n class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点        dummyHead-&gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作        ListNode* cur = dummyHead;        while (cur-&gt;next != NULL) &#123;            if(cur-&gt;next-&gt;val == val) &#123;                ListNode* tmp = cur-&gt;next;                cur-&gt;next = cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123;                cur = cur-&gt;next;            &#125;        &#125;        head = dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;\n\n采用递归的思路\n\n基础情况：对于空链表，不需要移除元素。\n递归情况：首先检查头节点的值是否为 val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为 val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果。\n\n class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        // 基础情况：空链表        if (head == nullptr) &#123;            return nullptr;        &#125;        // 递归处理        if (head-&gt;val == val) &#123;            ListNode* newHead = removeElements(head-&gt;next, val);            delete head;            return newHead;        &#125; else &#123;            head-&gt;next = removeElements(head-&gt;next, val);            return head;        &#125;    &#125;&#125;;\n\n\n707. 设计链表你可以选择使用单链表或者双链表，设计并实现自己的链表。单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n解析\n我觉得这是一道考验链表综合素质的题目，需要考虑到很多边界情况，当然还有index的问题，认真仔细做还是可以摸索下去的，因为本身对链表使用上并没有那么熟悉，因此这边也借鉴了不少卡哥的解析\n\n\n点击展开代码\n\nclass MyLinkedList &#123;public:    struct ListNode &#123;        int val;  // 节点上存储的元素        ListNode *next;  // 指向下一个节点的指针        ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数    &#125;;    MyLinkedList() &#123;        DummyHead = new ListNode(0);        NodeNum = 0;    &#125;        int get(int index) &#123;        if (index &gt; NodeNum - 1 || index &lt; 0)            return -1;        ListNode *RealHead = DummyHead-&gt;next;        while (index--)        &#123;            RealHead = RealHead-&gt;next;        &#125;        return RealHead-&gt;val;    &#125;        void addAtHead(int val) &#123;        ListNode *NewHead = new ListNode(val);        NewHead-&gt;next = DummyHead-&gt;next;        DummyHead-&gt;next = NewHead;        NodeNum++;    &#125;        void addAtTail(int val) &#123;        ListNode *NewTail = new ListNode(val);        ListNode *now = DummyHead;        while (now-&gt;next != nullptr)        &#123;            now = now-&gt;next;        &#125;        now-&gt;next = NewTail;        NodeNum++;    &#125;        void addAtIndex(int index, int val) &#123;        if (index &gt; NodeNum)            return;        index = index &lt;= 0 ? 0 : index;        ListNode *NewNode = new ListNode(val);        ListNode *now = DummyHead;        while (index--)        &#123;            now = now-&gt;next;        &#125;        NewNode-&gt;next = now-&gt;next;        now-&gt;next = NewNode;        NodeNum++;    &#125;        void deleteAtIndex(int index) &#123;        if(index &lt; 0 || index &gt;= NodeNum)            return;        ListNode *now = DummyHead;        while (index--)        &#123;            now = now-&gt;next;        &#125;        ListNode *temp = now-&gt;next;        now-&gt;next = now-&gt;next-&gt;next;        delete temp;        temp = nullptr;        NodeNum--;    &#125;private:    ListNode *DummyHead;    int NodeNum;&#125;;\n\n\n\n当然卡哥这边还写出了双链表的形式，思路和虚拟节点比较类似，创建了一个哨兵系节点，指向头节点和尾节点，这样就可以避免头节点为空的情况，同时也可以避免尾节点为空的情况。\n\n点击展开代码\n\n//采用循环虚拟结点的双链表实现class MyLinkedList &#123;public:    // 定义双向链表节点结构体    struct DList &#123;        int elem; // 节点存储的元素        DList *next; // 指向下一个节点的指针        DList *prev; // 指向上一个节点的指针        // 构造函数，创建一个值为elem的新节点        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) &#123;&#125;;    &#125;;    // 构造函数，初始化链表    MyLinkedList() &#123;        sentinelNode = new DList(0); // 创建哨兵节点，不存储有效数据        sentinelNode-&gt;next = sentinelNode; // 哨兵节点的下一个节点指向自身，形成循环        sentinelNode-&gt;prev = sentinelNode; // 哨兵节点的上一个节点指向自身，形成循环        size = 0; // 初始化链表大小为0    &#125;    // 获取链表中第index个节点的值    int get(int index) &#123;        if (index &gt; (size - 1) || index &lt; 0) &#123; // 检查索引是否超出范围            return -1; // 如果超出范围，返回-1        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index + 1; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标节点            &#125;        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标节点            &#125;        &#125;        num = curNode-&gt;elem; // 获取目标节点的值        return num; // 返回节点的值    &#125;    // 在链表头部添加节点    void addAtHead(int val) &#123;        DList *newNode = new DList(val); // 创建新节点        DList *next = sentinelNode-&gt;next; // 获取当前头节点的下一个节点        newNode-&gt;prev = sentinelNode; // 新节点的上一个节点指向哨兵节点        newNode-&gt;next = next; // 新节点的下一个节点指向原来的头节点        size++; // 链表大小加1        sentinelNode-&gt;next = newNode; // 哨兵节点的下一个节点指向新节点        next-&gt;prev = newNode; // 原来的头节点的上一个节点指向新节点    &#125;    // 在链表尾部添加节点    void addAtTail(int val) &#123;        DList *newNode = new DList(val); // 创建新节点        DList *prev = sentinelNode-&gt;prev; // 获取当前尾节点的上一个节点        newNode-&gt;next = sentinelNode; // 新节点的下一个节点指向哨兵节点        newNode-&gt;prev = prev; // 新节点的上一个节点指向原来的尾节点        size++; // 链表大小加1        sentinelNode-&gt;prev = newNode; // 哨兵节点的上一个节点指向新节点        prev-&gt;next = newNode; // 原来的尾节点的下一个节点指向新节点    &#125;    // 在链表中的第index个节点之前添加值为val的节点    void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123; // 检查索引是否超出范围            return; // 如果超出范围，直接返回        &#125;        if (index &lt;= 0) &#123; // 如果索引为0或负数，在头部添加节点            addAtHead(val);            return;        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标位置的前一个节点            &#125;            DList *temp = curNode-&gt;next; // 获取目标位置的节点            DList *newNode = new DList(val); // 创建新节点            curNode-&gt;next = newNode; // 在目标位置前添加新节点            temp-&gt;prev = newNode; // 目标位置的节点的前一个节点指向新节点            newNode-&gt;next = temp; // 新节点的下一个节点指向目标位置的结点            newNode-&gt;prev = curNode; // 新节点的上一个节点指向当前节点        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标位置的后一个节点            &#125;            DList *temp = curNode-&gt;prev; // 获取目标位置的节点            DList *newNode = new DList(val); // 创建新节点            curNode-&gt;prev = newNode; // 在目标位置后添加新节点            temp-&gt;next = newNode; // 目标位置的节点的下一个节点指向新节点            newNode-&gt;prev = temp; // 新节点的上一个节点指向目标位置的节点            newNode-&gt;next = curNode; // 新节点的下一个节点指向当前节点        &#125;        size++; // 链表大小加1    &#125;    // 删除链表中的第index个节点    void deleteAtIndex(int index) &#123;        if (index &gt; (size - 1) || index &lt; 0) &#123; // 检查索引是否超出范围            return; // 如果超出范围，直接返回        &#125;        int num;        int mid = size &gt;&gt; 1; // 计算链表中部位置        DList *curNode = sentinelNode; // 从哨兵节点开始        if (index &lt; mid) &#123; // 如果索引小于中部位置，从前往后遍历            for (int i = 0; i &lt; index; i++) &#123;                curNode = curNode-&gt;next; // 移动到目标位置的前一个节点            &#125;            DList *next = curNode-&gt;next-&gt;next; // 获取目标位置的下一个节点            curNode-&gt;next = next; // 删除目标位置的节点            next-&gt;prev = curNode; // 目标位置的下一个节点的前一个节点指向当前节点        &#125; else &#123; // 如果索引大于等于中部位置，从后往前遍历            for (int i = 0; i &lt; size - index - 1; i++) &#123;                curNode = curNode-&gt;prev; // 移动到目标位置的后一个节点            &#125;            DList *prev = curNode-&gt;prev-&gt;prev; // 获取目标位置的下一个节点            curNode-&gt;prev = prev; // 删除目标位置的节点            prev-&gt;next = curNode; // 目标位置的下一个节点的下一个节点指向当前节点        &#125;        size--; // 链表大小减1    &#125;private:    int size; // 链表的大小    DList *sentinelNode; // 哨兵节点的指针&#125;;\n\n\n\n206.反转链表\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n个人解析\n这边想的其实比较简单，采用双指针的方法，一个指针指向当前节点，一个指针指向当前节点的前一个节点，每次遍历到当前节点时，将当前节点的下一个节点指向前一个节点，然后将前一个节点指向当前节点，当前节点指向当前节点的下一个节点。即完成反转。\n\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode *now = head;        ListNode *pre = NULL;        while (now)        &#123;            ListNode *temp = now-&gt;next;            now-&gt;next = pre;            pre = now;            now = temp;        &#125;        return pre;    &#125;&#125;;\n卡哥解析当然卡哥这边还提出了两种办法\n\n递归法\n因为本身是重复性的操作，所以可以采用递归的方法。\n\n class Solution &#123;public:    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;        if(cur == NULL) return pre;        ListNode* temp = cur-&gt;next;        cur-&gt;next = pre;        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步        // pre = cur;        // cur = temp;        return reverse(cur,temp);    &#125;    ListNode* reverseList(ListNode* head) &#123;        // 和双指针法初始化是一样的逻辑        // ListNode* cur = head;        // ListNode* pre = NULL;        return reverse(NULL, head);    &#125;&#125;;\n从后向前翻转\n也是采用了递归的方法，不过顺序有所不同\n\n class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        // 边缘条件判断        if(head == NULL) return NULL;        if (head-&gt;next == NULL) return head;                // 递归调用，翻转第二个节点开始往后的链表        ListNode *last = reverseList(head-&gt;next);        // 翻转头节点与第二个节点的指向        head-&gt;next-&gt;next = head;        // 此时的 head 节点为尾节点，next 需要指向 NULL        head-&gt;next = NULL;        return last;    &#125;&#125;; \n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day1(数组01)","url":"/2026/01/14/coding_day1/","content":"   今天是2026年1月14日，是代码随想录的第一天，主要学习数组的相关知识。\n力扣题目及卡哥解析\n704. 二分查找\n卡哥解析：704. 二分查找\n\n\n27. 移除元素\n卡哥解析：27. 移除元素\n\n\n977.有序数组的平方\n卡哥解析：977.有序数组的平方\n\n\n\n题目解析704. 二分查找\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。\n你必须编写一个具有 O(log n) 时间复杂度的算法。\n\n个人解析   首先是704二分查找，题目要求在有序数组中查找目标值的索引，时间复杂度是O(log n)，空间复杂度是O(1)，刚刚好符合题目要求。   二分查找的思路是，每次取数组的中间元素，与目标值比较，如果相等则返回索引，如果中间元素大于目标值，则在左半部分继续查找，否则在右半部分继续查找。   乍一看这题目还以为回到了高中 (T.T)   因此直接贴出我的代码\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid +1            else:                right = mid -1        return -1\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0;        int right = nums.size() - 1;                while (left &lt;= right)        &#123;            int mid = (left + right) / 2;            if(nums[mid] == target)                return mid;            else if(nums[mid] &lt; target)                left = mid + 1;            else                right = mid - 1;        &#125;        return -1;    &#125;&#125;;\n\n卡哥解析\n我与卡哥这一道题的思路基本一致，原理就不展开了。\n不过，二分法的实现需重点关注边界条件，即搜索区间的取值范围及开闭区间的定义形式，具体可分为两种情况：\n若采用闭区间 [left, right] 的搜索形式，left 与 right 的初始值应分别设为 0 和 n-1。在每次迭代更新区间时，需 left &#x3D; mid + 1、right &#x3D; mid - 1，以此规避因区间无法收敛而导致的死循环问题。\n若采用开区间 [left, right) 的搜索形式，left 与 right 的初始值应分别设为 0 和 n。由于开区间的右边界 right 本身不包含在搜索范围内，因此迭代时只需 left &#x3D; mid + 1、right &#x3D; mid，无需额外对边界值进行加 1 或减 1 操作。\n\n\n\n\n27. 移除元素\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n个人解析\n拿到题目第一想法就是拿到两个指针，一个指向数组头部，一个指向数组尾部，然后分别向中间移动，当头部指针指向的值等于目标值时，就用尾部指针指向的值覆盖头部指针指向的值，然后尾部指针向中间移动，直到两个指针相遇。后来看解析才知道这是双指针方法\n最后返回新的数组长度，即头部指针的索引加一。这边当时没看仔细题目，一直想着要返回数组，测试一直不通过，迷迷糊糊折腾了好久才发现只需要返回新长度k值，而数组已经是修改过了的\n然后贴出我的代码\n\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int head = 0;        int tail = nums.size() - 1;        while (head &lt;= tail)         &#123;            if (nums[head] == val)             &#123;                nums[head] = nums[tail];                tail--;            &#125;             else                head++;        &#125;        return head;    &#125;&#125;;\n\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt; right:            if nums[left] == val:                nums[left] = nums[right]                right -= 1            else:                left += 1        return left\n\n卡哥解析\n卡哥给出了两种办法，分别是\n双指针法\n双指针法和我这个类似，就不过多解释\n\n\n快慢指针法\n快慢指针法的思路是，快指针用来遍历数组，慢指针用来指向新数组的最后一个元素。当快指针指向的值不等于目标值时，就用快指针指向的值覆盖慢指针指向的值，然后慢指针向中间移动。最后返回慢指针的索引加一。  具体代码为\n\n  class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n\n\n\n977. 有序数组的平方\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n个人解析\n看到题目想的也是双指针法，和卡哥类似，都是分别从头和尾部查看数组，比较其绝对值大小，再放入到新数组当中\n\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = nums.size() - 1;        int k = tail;        vector&lt;int&gt; res(nums.size());        while (head &lt;= tail) &#123;            if(abs(nums[head]) &gt; abs(nums[tail])) &#123;                res[k--] = nums[head] * nums[head];                head++;            &#125; else &#123;                res[k--] = nums[tail] * nums[tail];                tail--;            &#125;        &#125;        return res;    &#125;&#125;;\n\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        head = 0        tail = len(nums) - 1        k = tail        res = [0] * len(nums)        while head &lt;= tail:            if abs(nums[head]) &gt; abs(nums[tail]):                res[k] = nums[head] ** 2                head += 1            else:                res[k] = nums[tail] ** 2                tail -= 1            k -= 1        return res\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day2(数组02)","url":"/2026/01/15/coding-day2/","content":"今天是2026年1月15日，是代码随想录的第二天，主要学习数组的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n209.长度最小的子数组\n卡哥解析\n\n\n2\n59.螺旋矩阵II\n卡哥解析\n\n\n3\n卡哥58.区间和\n卡哥解析\n\n\n4\n卡哥44.开发商购买土地\n卡哥解析\n\n\n题目解析209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n个人解析\n首先是209，长度最小的子数组\n卡哥题目那边提了一嘴是滑动窗口，想了一下应该是应该和快慢指针类似，只不过这里是用一个指针指向窗口的头部，一个指针指向窗口的尾部，然后根据窗口内的元素和与目标值的比较，来移动指针，以此来逐渐寻找最小窗口，有了这样的思路那么代码就比较好写了。\n\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int head = 0;        int tail = 0;        int sum = 0;        int MiniLen = nums.size() + 1;        for (tail = 0; tail &lt; nums.size(); tail++) &#123;            sum += nums[tail];            while (sum &gt;= target)&#123;                if (MiniLen &gt; tail - head + 1)&#123;                    MiniLen = tail - head + 1;                &#125;                sum -= nums[head++];            &#125;        &#125;        return (MiniLen == (nums.size() + 1)) ? 0 : MiniLen;    &#125;&#125;;\n\n\n59. 螺旋矩阵 II\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵。\n\n个人解析\n拿到题目说实话并没有很好的思路，于是尝试暴力求解，根据矩阵的四个方向，分别填充数字，填充完成后，返回矩阵。\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        int up = 0;        int left = 0;        int down = n - 1;        int right = n - 1;        int count = 1;        vector&lt;vector&lt;int&gt;&gt;res(n, vector&lt;int&gt;(n,0));        while (left &lt;= right and up &lt;= down)&#123;            for (int i = left; i &lt; right + 1; i++)                res[up][i] = count++;            up++;            for (int i = up; i &lt; down + 1; i++)                res[i][right] = count++;            right--;            for (int i = right; i &gt; left - 1; i--)                res[down][i] = count++;            down--;            for (int i = down; i &gt;  up - 1; i--)                res[i][left] = count++;            left++;        &#125;        return res;    &#125;&#125;;\n\n卡哥解析\n卡哥的解法也是类似，只不过他首先判断的是总轮数，而我是判断的是当前数据是否满足条件。\n\n\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)        int count = 1; // 用来给矩阵中每一个空格赋值        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位        int i,j;        while (loop --) &#123;            i = startx;            j = starty;            // 下面开始的四个for就是模拟转了一圈            // 模拟填充上行从左到右(左闭右开)            for (j; j &lt; n - offset; j++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充右列从上到下(左闭右开)            for (i; i &lt; n - offset; i++) &#123;                res[i][j] = count++;            &#125;            // 模拟填充下行从右到左(左闭右开)            for (; j &gt; starty; j--) &#123;                res[i][j] = count++;            &#125;            // 模拟填充左列从下到上(左闭右开)            for (; i &gt; startx; i--) &#123;                res[i][j] = count++;            &#125;            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)            startx++;            starty++;            // offset 控制每一圈里每一条边遍历的长度            offset += 1;        &#125;        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值        if (n % 2) &#123;            res[mid][mid] = count;        &#125;        return res;    &#125;&#125;;\n\n\n\n58. 区间和\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n\n解析\n暴力求解就不提了，这里主要介绍一下前缀和的方法。\n前缀和是指一个数组的某下标之前的所有数组元素的和（包含其自身）。我们可以用一个数组 P 来表示原数组 A 的前缀和，即 P[i] &#x3D; A[0] + A[1] + … + A[i]。那么区间 [i, j] 的和就可以表示为 P[j] - P[i - 1]。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int n;    int head, tail;    int sum = 0;    cin &gt;&gt; n;    vector&lt;int&gt; nums(n);    vector&lt;int&gt; SumNums(n);    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        sum += nums[i];        SumNums[i] = sum;    &#125;    while (scanf(&quot;%d%d&quot;, &amp;head, &amp;tail) != EOF)    &#123;        if(head)            printf(&quot;%d\\n&quot;, SumNums[tail] - SumNums[head - 1]);        else            printf(&quot;%d\\n&quot;, SumNums[tail]);    &#125;    return 0;&#125;\n  由于对vector并不是很熟悉，在一开始初始化数组时一不小心将  vector&lt;int&gt; SumNums(n);  写成了  vector&lt;int&gt; SumNums[n];  而这种初始化方式是错误的，因为试图定义 vector 类型的数组，虽然合法但是这种并不适用在本题中。\n\n44. 开发商购买土地  在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。\n解析\n有了前缀和的铺垫，这一道题就很好理解了，本质是建立一个二维前缀和数组，用于快速计算任意子区域的土地总价值。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    int n, m, sum = 0, num;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;int&gt; rowSum(n, 0);    vector&lt;int&gt; colSum(m, 0);    int minDiff = INT_MAX;    int temp = 0;    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; m; j++)        &#123;            cin &gt;&gt; num;            sum += num;            rowSum[i] += num;            colSum[j] += num;        &#125;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        temp += rowSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    temp = 0;    for (int i = 0; i &lt; m; i++)    &#123;        temp += colSum[i];        minDiff = min(minDiff, abs(sum - 2 * temp));    &#125;    cout &lt;&lt; minDiff &lt;&lt; endl;    return 0;&#125;\n总结  这两天的题目主要是复习了数组的相关知识，包括二分法，双指针法，前缀和等。\n\n二分法：主要是要注意边界条件的处理，以及循环不变量的维护。\n双指针法：主要是要注意指针的移动条件，以及指针的边界处理。\n前缀和：其思想是将一个数组的前缀和存储在另一个数组中，通过前缀和数组可以快速计算任意子数组的和。\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"Hello World","url":"/2026/01/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["学习笔记"],"tags":["hexo"]},{"title":"my blog test","url":"/2026/01/12/my-blog-test/","content":"1.1 标题测试一级标题二级标题三级标题四级标题五级标题六级标题1.2 文本样式测试粗体文本斜体文本粗斜体文本删除线文本下划线文本高亮文本小号文本大号文本\n1.3 列表测试无序列表\n项目1\n项目2\n子项目2.1\n子项目2.2\n子子项目2.2.1\n\n\n\n\n\n有序列表\n第一个项目\n第二个项目\n子项目2.1\n子项目2.2\n\n\n第三个项目\n\n任务列表\n 完成的任务\n 未完成的任务\n 已完成的任务2\n\n2. 代码测试2.1 行内代码这里是行内代码 console.log(&#39;Hello World&#39;) 的测试。\n2.2 代码块测试JavaScript代码function hello() &#123;  console.log(&#x27;Hello, Hexo!&#x27;);&#125;hello();\n\nPython代码def hello():    print(&quot;Hello, Hexo!&quot;)hello()\n\nHTML代码&lt;div class=&quot;test&quot;&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  &lt;p&gt;This is a test&lt;/p&gt;&lt;/div&gt;\n\nCSS代码.test &#123;  color: red;  font-size: 16px;&#125;\n\n3. 链接和图片测试3.1 普通链接Hexo官方网站\n3.2 带标题的链接Hexo官方网站\n3.3 图片测试\n3.4 带链接的图片\n4. 引用测试4.1 基本引用\n这是一段引用文本。引用可以跨越多行。\n\n4.2 嵌套引用\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n4.3 引用中包含其他元素\n引用中的标题\n引用中的列表项1\n引用中的列表项2\n\n引用中的普通文本。\n\n5. 表格测试5.1 基本表格\n\n\n姓名\n年龄\n职业\n\n\n\n张三\n25\n工程师\n\n\n李四\n30\n设计师\n\n\n王五\n35\n产品经理\n\n\n5.2 对齐方式测试\n\n\n左对齐\n居中对齐\n右对齐\n\n\n\n内容1\n内容2\n内容3\n\n\n长内容1\n长内容2\n长内容3\n\n\n6. 分隔线测试这是上面的内容。\n\n这是中间的内容。\n\n这是下面的内容。\n7. 脚注测试这是一段带有脚注的文本^1。这是另一段带有脚注的文本^2。\n这是脚注的第二行。\n\n8. 数学公式测试8.1 行内公式E &#x3D; mc²\n8.2 块级公式$$\\int_{a}^{b} f(x) dx &#x3D; F(b) - F(a)$$\n9. 特殊语法测试9.1 自动链接https://hexo.iotest@example.com\n9.2 反斜杠转义*这不是斜体*_这不是下划线_#这不是标题#\n9.3 表情符号测试:smile: :laughing: :blush: :smiley: :relaxed:\n10. Hexo特定功能测试10.1 前置声明测试本文档使用了以下前置声明：\n\ntitle: 博客书写功能测试\ndate: 2026-01-12 12:00:00\ntags: 测试, 功能\ncategories: 技术\n\n10.2 标签和分类测试标签：测试、功能分类：技术\n10.3 代码高亮测试// 这是一段JavaScript代码const hexo = &#x27;Hexo&#x27;;console.log(`Welcome to $&#123;hexo&#125;!`);","categories":["学习笔记"],"tags":["test"]},{"title":"代码随想录_day4(链表02)","url":"/2026/01/17/coding_day4/","content":"今天是2026年1月17日，是代码随想录的第四天，主要学习数组的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n24. 两两交换链表中的节点\n卡哥解析\n\n\n2\n19.删除链表的倒数第N个节点\n卡哥解析\n\n\n3\n160.链表相交\n卡哥解析\n\n\n4\n142.环形链表II\n卡哥解析\n\n\n题目解析24. 两两交换链表中的节点\n给定一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n解析\n这道题目难度不大，只需要注意一下，交换节点时，需要注意一下节点的顺序，以及交换完成后，需要将指针指向下一个节点。\n\nclass Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode *DummyHead = new ListNode(0);        DummyHead-&gt;next = head;        ListNode *now = DummyHead;        while(now-&gt;next != nullptr &amp;&amp; now-&gt;next-&gt;next != nullptr)        &#123;            ListNode *TempHead = now-&gt;next;            ListNode *TempTail = now-&gt;next-&gt;next-&gt;next;            now-&gt;next = now-&gt;next-&gt;next;            now-&gt;next-&gt;next = TempHead;            now-&gt;next-&gt;next-&gt;next = TempTail;            now = now-&gt;next-&gt;next;        &#125;        ListNode *result = DummyHead-&gt;next;        delete DummyHead;        return result;    &#125;&#125;;\n不过一开始时并没有删除这个虚拟头节点，后来才删除。要注意new出来的节点，最后要delete掉，否则会内存泄漏。\n\n19.删除链表的倒数第N个节点\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n解析\n拿到题目想了一下，如果只扫描一遍的话，那应该需要采用双指针的方法，一个指针指向头节点，一个指针指向第n个节点。然后两个指针同时移动，直到快指针指向nullptr，此时慢指针指向的节点就是倒数第n个节点。根据这样的思路，可以在扫描一遍的情况下，删除倒数第n个节点。\n不过对于new出来的节点，最后要delete。\n\nclass Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *DummyHead = new ListNode(0);        DummyHead-&gt;next = head;        ListNode *first = DummyHead;        ListNode *last = DummyHead;        n = n + 1;        while(first != nullptr)        &#123;            first = first-&gt;next;            if(n-- &gt; 0)                continue;            last = last-&gt;next;        &#125;        ListNode *temp = last-&gt;next;        last-&gt;next = last-&gt;next-&gt;next;        delete temp;        ListNode *result = DummyHead-&gt;next;        delete DummyHead;        return result;    &#125;&#125;;\n\n\n160.链表相交\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n解析\n拿到题目一开始并没有很好的思路，扫了一下卡哥发现卡哥是利用长度差来解决的\n仔细一想，既然可以利用长度差解决，那也可以利用长度和来解决，A+B&#x3D;B+A，所以如果两个链表相交，那么从相交点开始，到链表结束，两个链表的长度是相同的，只需要判断两个指针是否相同即可\n\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *ListA = headA;        ListNode *ListB = headB;        while (ListA != ListB)        &#123;            ListA = (ListA == nullptr) ? headB : ListA-&gt;next;            ListB = (ListB == nullptr) ? headA : ListB-&gt;next;        &#125;        return ListA;    &#125;&#125;;\n  卡哥采用长度差的办法，也在下面写出\n\n卡哥解析代码\n\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode* curA = headA;        ListNode* curB = headB;        int lenA = 0, lenB = 0;        while (curA != NULL) &#123; // 求链表A的长度            lenA++;            curA = curA-&gt;next;        &#125;        while (curB != NULL) &#123; // 求链表B的长度            lenB++;            curB = curB-&gt;next;        &#125;        curA = headA;        curB = headB;        // 让curA为最长链表的头，lenA为其长度        if (lenB &gt; lenA) &#123;            swap (lenA, lenB);            swap (curA, curB);        &#125;        // 求长度差        int gap = lenA - lenB;        // 让curA和curB在同一起点上（末尾位置对齐）        while (gap--) &#123;            curA = curA-&gt;next;        &#125;        // 遍历curA 和 curB，遇到相同则直接返回        while (curA != NULL) &#123;            if (curA == curB) &#123;                return curA;            &#125;            curA = curA-&gt;next;            curB = curB-&gt;next;        &#125;        return NULL;    &#125;&#125;;\n\n\n\n142. 环形链表II\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改链表。\n\n解析\n一开始并没有很好的方法，想的是存储每个节点，然后遍历链表，判断是否有节点在存储的数组中出现过。但是这样的方法空间复杂度是O(n)，时间复杂度应该是O(n^2)，不符合题目要求。\n看了卡哥的解析，发现可以用快慢指针的方法，快指针每次移动两步，慢指针每次移动一步， 如果有环，那么快指针一定会追上慢指针。如果没有环，那么快指针会先到达nullptr。\n当快慢指针相遇时，假设慢指针走了k步，那么快指针走了2k步。假设环的长度为r，那么快指针比慢指针多走了n圈环，即2k-k&#x3D;nr。所以k&#x3D;nr。\n假设链表头到环的入口点的距离为a，环的入口点到快慢指针相遇点的距离为b，那么慢指针走的距离为a+b，快指针走的距离为a+b+nr。因为快指针走的距离是慢指针的两倍，所以2(a+b)&#x3D;a+b+nr，即a+b&#x3D;nr。\n所以可以得到a&#x3D;nr-b&#x3D;(n-1)r+b，即链表头到环的入口点的距离等于n-1圈环的长度加上环的入口点到快慢指针相遇点的距离。\n所以当快慢指针相遇时，将快指针重新指向链表头，然后快慢指针每次都移动一步，当它们再次相遇时，就是环的入口点。\n\n想出这个办法的人真是天才\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        ListNode *fast = head;        ListNode *slow = head;        while(fast != NULL &amp;&amp; fast-&gt;next != NULL)        &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if(slow == fast)            &#123;                ListNode *TempFast = fast;                ListNode *TempSlow = head;                while(TempFast != TempSlow)                &#123;                    TempFast = TempFast-&gt;next;                    TempSlow = TempSlow-&gt;next;                &#125;                return TempFast;            &#125;        &#125;        return NULL;    &#125;&#125;;\n不过其实我发现我那个想法也可以，官方利用哈希表实现了\nclass Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode *&gt; visited;        while (head != nullptr) &#123;            if (visited.count(head)) &#123;                return head;            &#125;            visited.insert(head);            head = head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;\n\n总结  这两天的题目主要是复习了链表的相关知识，包括虚拟头节点，链表的基本操作，判断环等。\n\n虚拟头节点：虚拟头节点是一个指向头节点的指针，它的作用是简化链表的操作，比如删除头节点时，不需要特殊处理。\n链表的基本操作：包括遍历，插入，删除等。\n判断环：可以利用快慢指针的方法，快指针每次移动两步，慢指针每次移动一步，如果有环，那么快指针一定会追上慢指针。如果没有环，那么快指针会先到达nullptr。\n\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day6(哈希表01)","url":"/2026/01/19/coding_day6/","content":"今天是2026年1月19日，是代码随想录的第六天，主要学习哈希表的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n242.有效的字母异位词\n卡哥解析\n\n\n2\n349. 两个数组的交集\n卡哥解析\n\n\n3\n202. 快乐数\n卡哥解析\n\n\n4\n1. 两数之和\n卡哥解析\n\n\n题目解析242. 有效的字母异位词\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n解析\n这道题目难度不大，可以利用数组或者哈希表来统计每个字母出现的次数，然后比较两个字符串中每个字母出现的次数是否相同即可\n\nclass Solution &#123;public:    bool isAnagram(string s, string t) &#123;        int count[26] = &#123;0&#125;;        for (char c : s) &#123;            count[c - &#x27;a&#x27;]++;        &#125;        for (char c : t) &#123;            count[c - &#x27;a&#x27;]--;        &#125;        for (int i = 0; i &lt; 26; i++) &#123;            if (count[i] != 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n这里遇到了新的cpp中for的写法，是传统for的简化版\nfor (元素类型 变量名 : 可遍历对象) &#123;    // 循环体：对每个元素执行的操作&#125;\n若要修改元素值，可以使用引用类型\nfor (元素类型&amp; 变量名 : 可遍历对象) &#123;    // 循环体：对每个元素执行的操作&#125;for (char &amp;c : s) &#123; // 注意这里的 &amp;        c = toupper(c); // toupper 把小写转大写，需要 &lt;cctype&gt; 头文件    &#125;\n\n\n349. 两个数组的交集\n给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n\n解析\n这道题目思路感觉比较直接，可以利用哈希表来解决，先将第一个数组的元素存入哈希表中，然后遍历第二个数组，判断每个元素是否在哈希表中出现过，如果出现过，则将其加入结果集中，并从哈希表中删除该元素，避免重复加入。\n\nclass Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; nums_set1;        unordered_set&lt;int&gt; result;        for (int num : nums1)            nums_set1.insert(num);        for (int num : nums2) &#123;            if (nums_set1.count(num)) &#123;                result.insert(num);            &#125;        &#125;        return vector&lt;int&gt;(result.begin(), result.end());    &#125;&#125;;\n\n\n202. 快乐数\n编写一个算法来判断一个数 n 是不是快乐数。「快乐数」 定义为：\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n如果这个过程 结果为 1，那么这个数就是快乐数。\n如果 n 是 快乐数 就返回 true ；不是，则返回 false。\n\n解析\n拿到题目一开始并没有什么思路，但是卡哥提到说是无限循环，那么这道题就变得简单了，可以利用哈希表来存储每次计算的结果，如果出现过，那么就说明进入了无限循环，返回false；如果计算结果为1，则返回true。\n\nclass Solution &#123;public:    bool isHappy(int n) &#123;        unordered_set&lt;int&gt; num;        while (n != 1) &#123;            if (num.count(n)) &#123;                return false;            &#125;            num.insert(n);            int sum = 0;            while (n) &#123;                int digit = n % 10;                sum += digit * digit;                n /= 10;            &#125;            n = sum;        &#125;        return true;    &#125;&#125;;\n\n\n1. 两数之和\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n解析\n这道题目是经典的两数之和问题，可以利用哈希表来存储每个元素及其对应的下标，然后在遍历数组时，计算出目标值与当前元素的差值，判断该差值是否在哈希表中出现过，如果出现过，则返回该差值对应的下标和当前元素的下标。\n需要注意的是，不能使用同一个元素两次，所以在存储元素时，需要先判断差值是否存在，再存储当前元素。\n还有就是这道题中由于需要范围下表，可以使用map。\n\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; num_map;        for (int i = 0; i &lt; nums.size(); i++) &#123;            int complement = target - nums[i];            if (num_map.count(complement)) &#123;                return &#123;num_map[complement], i&#125;;            &#125;            num_map[nums[i]] = i;        &#125;        return &#123;&#125;;    &#125;&#125;;\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day7(哈希表02)","url":"/2026/01/20/coding_day7/","content":"今天是2026年1月20日，是代码随想录的第七天，主要学习哈希表的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n454.四数相加II\n卡哥解析\n\n\n2\n383. 赎金信\n卡哥解析\n\n\n3\n15. 三数之和\n卡哥解析\n\n\n4\n18. 四数之和\n卡哥解析\n\n\n题目解析454. 四数相加II\n给你四个整数数组 nums1、nums2、nums3 和 nums4 ,数组长度都是 n,请你计算有多少个元组 (i, j, k, l) 能满足：\n0 &lt;&#x3D; i, j, k, l &lt; n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0\n其中 n 是数组的长度。\n\n解析\n这道题思路也比较直接，可以利用哈希表来解决，先将前两个数组的所有可能的和存入哈希表中，然后遍历后两个数组，计算出它们的和的相反数，判断该值是否在哈希表中出现过，如果出现过，则将其对应的次数加入结果集中。以此来将复杂度从O(n^4)降低到O(n^2)。\n\nclass Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        unordered_map&lt;int, int&gt; absum;        unordered_map&lt;int, int&gt; cdsum;        int count = 0;        for (int i : nums1)        &#123;            for (int j : nums2)            &#123;                absum[i + j]++;            &#125;        &#125;        for (int i : nums3)        &#123;            for (int j : nums4)            &#123;                if(absum.find(0 - (i + j)) != absum.end())                    count += absum[0 - (i + j)];            &#125;        &#125;        return count;    &#125;&#125;;\n\n\n383. 赎金信\n给你两个字符串 ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\n如果可以，返回 true ；否则返回 false 。\n\n解析\n这道题目思路也比较直接，可以利用哈希表来解决，先将 magazine 中的每个字符出现的次数存入哈希表中，然后遍历 ransomNote 中的每个字符，判断该字符是否在哈希表中出现过且次数大于0，如果是，则将该字符对应的次数减1；如果不是，则返回false。\n\nclass Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int str[26] = &#123;0&#125;;        for (char s : magazine)            str[s - &#x27;a&#x27;]++;        for (char s : ransomNote)        &#123;            str[s - &#x27;a&#x27;]--;            if (str[s - &#x27;a&#x27;] &lt; 0)                return false;        &#125;        return true;    &#125;&#125;;\n\n\n15. 三数之和\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n\n解析\n这道题目可以采用两种办法解决，一是利用哈希表暴力求解，但是对于元素的去重不好操作，二是双指针法。这里采用双指针法来解决，首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针法在剩下的元素中寻找两个数，使得它们的和等于当前元素的相反数。需要注意的是，为了避免重复三元组，需要在遍历过程中跳过相同的元素。\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        int head = 0, mid, tail = nums.size() - 1;                while (head &lt; nums.size() - 2)        &#123;            if (nums[head] &gt; 0) break;            mid = head + 1;            tail = nums.size() - 1;            while (mid &lt; tail)            &#123;                if(nums[head] + nums[mid] + nums[tail] == 0)                &#123;                    result.push_back(&#123;nums[head], nums[mid], nums[tail]&#125;);                    while (mid &lt; tail &amp;&amp; nums[mid] == nums[mid + 1])                        mid++;                    while (mid &lt; tail &amp;&amp; nums[tail] == nums[tail - 1])                        tail--;                    mid++;                    tail--;                &#125;                else if (nums[head] + nums[mid] + nums[tail] &lt; 0)                    mid++;                else                    tail--;            &#125;            while (head &lt; nums.size() - 2 &amp;&amp; nums[head] == nums[head + 1])                head++;            head++;        &#125;        return result;    &#125;&#125;;\n\n\n18. 四数之和\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] ：\n0 &lt;&#x3D; a, b, c, d &lt; n\na、b、c 和 d 互不相同。\nnums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target\n\n解析\n这道题的本质就是前一道题再加一个循环，固定两个元素来寻找另外两个元素，其他的逻辑和三数之和类似。\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        if (nums.size() &lt; 4) return result;        int i = 0, j = 1, m, n = nums.size() - 1;        for (i = 0; i &lt; nums.size() - 3; i++)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;                break;            &#125;            j = i + 1;            for (int j = i + 1; j &lt; nums.size() - 2; j++)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;                m = j + 1;                n = nums.size() - 1;                while (m &lt; n)                &#123;                    if((long)nums[i] + nums[j] + nums[m] + nums[n] == target)                    &#123;                        result.push_back(&#123;nums[i],nums[j], nums[m], nums[n]&#125;);                        while (m &lt; n &amp;&amp; nums[m] == nums[m + 1])                            m++;                        while (m &lt; n &amp;&amp; nums[n] == nums[n - 1])                            n--;                        m++;                        n--;                    &#125;                    else if ((long)nums[i] + nums[j] + nums[m] + nums[n] &lt; target)                        m++;                    else                        n--;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]},{"title":"代码随想录_day8(字符串01)","url":"/2026/01/21/coding_day8/","content":"今天是2026年1月21日，是代码随想录的第八天，主要学习字符串的相关知识。\n题目及卡哥解析\n\n\n序号\n题目\n解析\n\n\n\n1\n344.反转字符串\n卡哥解析\n\n\n2\n541. 反转字符串II\n卡哥解析\n\n\n3\n卡码网：54.替换数字\n卡哥解析\n\n\n题目解析344. 反转字符串\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n解析\n这道题思路比较直接，由于不可以使用额外的空间，所以只能使用双指针法来解决，一个指针指向字符串的开头，另一个指向字符串的结尾，然后交换两个指针所指向的字符，之后将两个指针分别向中间移动，直到两个指针相遇为止。\n\nclass Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int head = 0;        int tail = s.size() - 1;        while (head &lt; tail) &#123;            swap(s[head], s[tail]);            head++;            tail--;        &#125;    &#125;&#125;;\n\n\n541. 反转字符串II给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n解析\n这道题目思路也比较直接，使用双指针法来解决，遍历字符串，每次移动 2k 个字符，然后对前 k 个字符进行反转操作。\n\nclass Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n = s.size();        int ptr = 0;        while(ptr &lt; n)        &#123;            int left = ptr;            int right = min(ptr + k - 1, n - 1);            reverse(s.begin() + left, s.begin() + right + 1);            ptr += 2 * k;        &#125;        return s;    &#125;&#125;;\n\n\n卡码网：54. 替换数字\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。\n\n解析\n这道题目也可以使用双指针法，从后向前遍历字符串，当遇到数字字符时，就替换为 “number”。\n\nusing namespace std;#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;bitset&gt;#include &lt;climits&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;string&gt;int main()&#123;    string s;    cin &gt;&gt; s;    int count = 0, left = s.size() - 1, right = 0;    for (char i : s)        if (i &gt;= &#x27;0&#x27; &amp;&amp; i &lt;= &#x27;9&#x27;)count++;    right = left + count * 5;    s.resize(s.size() + count * 5);    while(left &gt;= 0)    &#123;        if (s[left] &gt;= &#x27;0&#x27; &amp;&amp; s[left] &lt;= &#x27;9&#x27;)        &#123;            right -= 5;            s.replace(right, 6, &quot;number&quot;);        &#125;        else        &#123;            s[right] = s[left];        &#125;        right--;        left--;    &#125;    cout &lt;&lt; s &lt;&lt; endl;    return 0;&#125;","categories":["代码随想录","学习笔记"],"tags":["代码随想录"]}]